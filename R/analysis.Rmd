---
title: "Artificial Ecosystem Selection: Methane Oxidation"
author: "Andrew Morris"
output:
  html_document:
      toc: true
      toc_float: 
        collapsed: false
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  fig.align="center")
library(tidyverse)
library(knitr)
library(kableExtra)
library(broom)
library(modelr)
library(lubridate)
library(morris)
library(magrittr)
library(metafor)
library(lme4)
```

# Standard Curves

Standard curves for each sc_date. (Some flux_dates have multiple standard curves if the instrument drifted from day to day as indicated by check standards.)

```{r sc_data, fig.height=4}

sc <- read.csv('../Data/standard_curve.csv')
sc_dates <- read.csv('../Data/sc_dates.csv')

# sc %>% 
#   filter(molecule == 'ch4') %>% 
# ggplot(mapping = aes(area, injection_ppm)) +
#   facet_wrap(~ sc_date + molecule, scales = "free") + 
#   geom_point() +
#   stat_smooth(formula = y ~ x, method = 'lm', se = FALSE)

sc_model <- function(df) {lm(injection_ppm ~ area, data = df)}
standard_curves <- 
  sc %>% 
  filter(molecule == 'ch4') %>% 
  group_by(flux_date, sc_date) %>% 
  nest() %>% 
  mutate(model = map(data, sc_model),
         glance = map(model, glance),
         tidy = map(model, tidy)) 
sc_r2 <- 
  standard_curves %>% 
  unnest(glance) %>% 
  select(flux_date, sc_date, r.squared)
sc_equation <- 
  standard_curves %>% 
  unnest(tidy) %>%
  select(flux_date, sc_date, term, estimate) %>% 
  spread(term, estimate) %>% 
  rename(intercept = `(Intercept)`, slope = area)
sc_ch4 <- left_join(sc_r2, sc_equation, by = c("flux_date", "sc_date"))

# sc_ch4 %>% 
#   kable() %>% 
#   kable_styling()

sc_ch4 <- 
sc_ch4 %>% 
  left_join(sc_dates, by = "sc_date") %>% 
  select(flux_date:sc_date, t, r.squared:slope)

```


# Fluxes

```{r time_data}
time_data <- data.table::fread('../Data/time_data.csv')

time_data[, c('t0', 't1', 't2', 't3', 't4', 't5')] <- 
  lapply(time_data[, c('t0', 't1', 't2', 't3', 't4', 't5')],
         ymd_hms)

as.days <- function(start, end) {as.numeric(interval(start, end))/60/60/24}

time_data[, c('t1', 't2', 't3', 't4', 't5')] <- 
  lapply(time_data[, c('t1', 't2', 't3', 't4', 't5')],
         function(x) as.days(time_data$t1, x))
time_data <- 
 time_data %>% 
  select(-t0) %>% 
  gather(t, days, t1:t5) %>% 
  mutate(flux_date = factor(flux_date))
```

```{r}
conc_data <- data.table::fread('../Data/conc_data.csv')

conc_data <- 
  conc_data %>% 
  filter(molecule == 'ch4') %>% 
  mutate(flux_date = factor(flux_date)) %>% 
  gather(t, area, t1:t5) %>% 
  left_join(sc_ch4, by = c('flux_date', 't')) %>% 
  mutate(ppm = area * slope + intercept) %>% 
  select(flux_date, jar, t, ppm) %>% 
  spread(t, ppm)

ln_ch0_chn <- function(t0, tn) {
  log(t0/tn)
}

conc_data[, c('t1', 't2', 't3', 't4', 't5')] <- 
  lapply(conc_data[, c('t1', 't2', 't3', 't4', 't5')],
         function(x) ln_ch0_chn(conc_data$t1, x))

flux_data <-
  conc_data %>% 
  gather(t, ppm, t1:t5) %>% 
  left_join(time_data, by = c('flux_date', 'jar', 't'))

flux_data <- 
  flux_data %>% 
  mutate(flux_date = factor(ymd(flux_date)), 
         jar = factor(jar),
         t = factor(t)) %>% 
  mutate(rep = factor(substr(jar, 2, 3)),
         treat = factor(substr(jar, 1, 1)))
```

Each column is jar by number (the jar numbers are arbitrary - there is no relationship between the communities of jar 01, passage 1 and jar 01, passage 2). Rows are each selection treatment (positive = p, neutral = n) within each passage (indicated by the date flux was measured). Lines are proportion of ppm CH4 consumed per day.

```{r flux_curves, warning = FALSE, fig.height=8}

flux_data %>% 
  ggplot(aes(days, ppm)) + 
  facet_grid(flux_date + treat ~ rep, scales = "free") +
  geom_point() + 
  stat_smooth(method = 'lm', formula = y ~ x)

```

```{r flux_model}
lin_model <- function(dt) {
  lm(ppm ~ days, data = dt)
}

nested <- 
  flux_data %>% 
  group_by(flux_date, jar, treat, rep) %>% 
  nest() %>% 
  mutate(model = map(data, lin_model))

fluxes <-
  nested %>% 
  mutate(tidy = map(model, tidy)) %>% 
  unnest(tidy) %>% 
  filter(term == 'days') %>% 
  group_by(flux_date) %>% 
  arrange(estimate, .by_group = TRUE) %>% 
  select(-data, -model, -term) %>% 
  ungroup() %>% 
  mutate(passage = as.numeric(flux_date)) %>% 
  mutate(estimate_rank = rank(estimate)) %>% 
  filter(passage != 6)

write_tsv(fluxes, '../Output/fluxes.tsv')

```

Histograms and boxplots of flux estimates for each jar within each treatment. The numbered points give an indication of which jars were the greatest methane consumers

```{r plot_estimates}
# ggplot(fluxes, aes(x = estimate, fill = treat)) +
#   facet_wrap(~ flux_date, scales = "free") +
#   geom_histogram(position = 'identity', alpha = 0.5, bins = 20)

ggplot(fluxes, aes(y = estimate, x = treat, color = treat)) +
  facet_wrap(~ flux_date, scales = "free") +
  geom_boxplot(outlier.shape = NA) +
  geom_label(aes(label = rep))
```

# Response to Selection

```{r deviance, eval=FALSE, include=FALSE}
# Calculate deviance as p - n
deviance <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  group_by(passage, treat) %>% 
  summarize(mean = mean(estimate), .groups = "drop") %>% 
  pivot_wider(names_from = treat, values_from = mean) %>% 
  mutate(deviance = p - n)

# Create se function that can handle NAs
se <- function(x, na.rm = FALSE){
  sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), 
    na.rm = na.rm)) / sqrt(length(if (na.rm == TRUE) na.omit(x) else x))
}

# Standard error of the difference function
sed <- function(p, n, na.rm = FALSE) {
  sqrt(se(p, na.rm = na.rm) ^ 2 + se(n, na.rm = na.rm)^ 2)
}

# Calculate variance of deviance as SED
deviance$se <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  mutate(x = 1:nrow(fluxes)) %>% 
  pivot_wider(names_from = treat, values_from = estimate) %>% 
  group_by(passage) %>% 
  summarize(sed = sed(p, n, na.rm = TRUE), .groups = "drop") %>%
  pull(sed)

# Fit deviance model
fit <- rma(deviance ~ passage, se^2, method="FE", data = deviance)

# Plot deviance
ggplot(deviance, aes(x = passage, y = deviance, ymin = deviance - se, ymax = deviance + se)) + 
  geom_pointrange(color = 'darkorange2') + 
  geom_abline(intercept = fit$beta[1], slope = fit$beta[2])

# Take deviance model parameters and export into a data.frame
rma_output <- data.frame(
Estimate = fit$beta,
se = fit$se,
z.value = fit$zval,
p.value = fit$pval,
upper.ci = fit$ci.lb,
lower.ci = fit$ci.ub
)

# Fit deviance model without passage 2
fit_no2 <- 
filter(deviance, passage != 2) %>% 
rma(deviance ~ passage, se^2, method="FE", data = .)

# Take deviance model withou passage 2 parameters and export into a data.frame

rma_output_no2 <- data.frame(
Estimate = fit$beta,
se = fit$se,
z.value = fit$zval,
p.value = fit$pval,
upper.ci = fit$ci.lb,
lower.ci = fit$ci.ub
)

# R (response to selection) for the no2 model
R_no2 <- rma_output_no2[[2, 1]]
R <- rma_output[[2, 1]]

# Plot the no2 model
filter(deviance, passage != 2) %>% 
ggplot(., aes(x = passage, y = deviance, ymin = deviance - se, ymax = deviance + se)) + 
  geom_pointrange(color = 'darkorange2') + 
  geom_abline(intercept = fit_no2$beta[1], slope = fit_no2$beta[2])

# Print the full model
rma_output %>% 
  kable() %>% 
  kable_styling()

write.csv(deviance, '../Output/deviance.tsv')
```

# Heritability

```{r create_heritability_data, message=FALSE, warning=FALSE}
selected_jars <- read_csv('../Data/selected.csv')

# Pull out the selected parental jars
selected <- 
  fluxes[paste0(fluxes$passage, fluxes$jar) %in% paste0(selected_jars$passage, selected_jars$jar), ] %>%
  select(treat, estimate, passage)

# Pull out all parental jars
parental <-
  fluxes %>% 
  select(passage, treat, estimate)

# Pull out all offspring jars
offspring <- 
  fluxes %>%
  select(treat, estimate, passage) %>% 
  filter(passage != 1) %>% 
  mutate(passage = passage - 1)
```


```{r heritability_mean}

# Calculate means for east generation
parental_mean <-
  parental %>% 
  group_by(passage, treat) %>% 
  summarize(parental = mean(estimate), .groups = "drop")

offspring_mean <-
  offspring %>% 
  group_by(passage, treat) %>% 
  summarize(offspring = mean(estimate), .groups = "drop")

selected_mean <-
  selected %>% 
  group_by(passage, treat) %>% 
  summarize(selected = mean(estimate), .groups = "drop")

# Combine all parent/offspring data into one data frame
heritability <- 
  parental_mean %>% 
  left_join(offspring_mean, by = c("passage", "treat")) %>% 
  left_join(selected_mean, by = c("passage", "treat")) %>% 
  #filter(treat == "p") %>% 
  filter(passage != 5) %>% # Remove passage 5, which has no offspring
  ungroup()


write_tsv(heritability, '../Output/heritability.tsv')

```


``` {r generation_h2}


######################################################################
# This is where you stopped
# Figure out why h2 is different from h2_calc_method
# Finish writing your email to brendan about heritability
######################################################################

# Function for the Breeder's equation

breeders <- function(R, S) {
  R / S
}

# Calculate h2 (heritability) using math, not regression
# For each generation and then calculate the mean/se
h2_calc_method <-
  heritability %>%
  filter(treat == "p") %>%
  mutate(S = selected - parental) %>%
  mutate(R = offspring - parental) %>%
  mutate(h2 = breeders(R, S)) %>%
  summarize(S = mean(S),
            R = mean(R),
            se = se(h2),
            h2 = mean(h2))

h2_calc_method_no_2 <-
  heritability %>%
  filter(treat == "p") %>%  
  filter(passage != 2) %>%
  mutate(S = selected - parental) %>%
  mutate(R = offspring - parental) %>%
  mutate(h2 = breeders(R, S)) %>%
  summarize(S = mean(S),
            R = mean(R),
            se = se(h2),
            h2 = mean(h2))
h2 <- 
  h2_calc_method %>% 
  mutate(method = "calc p")
h2_no2 <- 
  h2_calc_method_no_2 %>% 
  mutate(method = "calc p no 2")

h2 <- rbind(h2, h2_no2)
```

```{r h2_slope_method}

# Calculate S (selection differential) with/without passage 2

S <-
  heritability %>%
  filter(treat == "p") %>%
  mutate(S = abs(selected - parental)) %>%
  summarize(S = mean(S)) %>% 
  pull()
S_no2 <-
  heritability %>%
  filter(treat == "p") %>%
  filter(passage != 2) %>% 
  mutate(S = abs(selected - parental)) %>%
  summarize(S = mean(S)) %>% 
  pull()

# For the equivalent plot of Falconer and MacKay
# Scale and center all fluxes
heritability_scaled <-
  heritability %>% 
  pivot_longer(parental:selected) %>% 
  mutate(value = scale(value)) %>% 
  pivot_wider(names_from = "name", values_from = "value")

# Calculate R and S 
R_and_S <-
  heritability_scaled %>% 
  filter(treat == "p") %>% 
  summarize(R = mean(offspring),
            S = mean(selected))

# Calculate scaled h2
R <- R_and_S[[1, 'R']]
S <- R_and_S[[1, 'S']]
h2 <- breeders(R, S)

# Plot scaled h2
ggplot(data = heritability_scaled, aes(x = selected, y = offspring)) +
  geom_point(aes(shape = treat)) +
  scale_shape_manual(values = c(1,19), name = "Treatment", labels = c('Neutral', 'Positive')) +
  stat_smooth(se = FALSE, method = "lm", formula = y ~ x, color = 'black') +
  labs(x = "Selected Parents", y = "Offspring") +
  geom_segment(aes(x = 0, y = R, xend = S, yend = R), linetype = 3) +
  geom_segment(aes(x = S, y = 0, xend = S, yend = R), linetype = 3) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_text(label = "R", x = -0.1, y = R) +
    geom_text(label = "S", x = S, y = -0.2)


```

```{r}
heritability %>% 
  ggplot(aes(parental, offspring, color = treat)) +
  geom_point() +
  labs(x = "Parental", y = "Offspring") +
  theme_bw() +
  scale_color_discrete(name = "Treatment", labels = c('Neutral', 'Positive'))

summary(lm(offspring ~ parental, data = heritability))
```
```{r}
heritability %>% 
  ggplot(aes(selected, offspring, color = treat)) +
  geom_point() +
  labs(x = "Selected", y = "Offspring") +
  theme_bw() +
  scale_color_discrete(name = "Treatment", labels = c('Neutral', 'Positive'))
```

