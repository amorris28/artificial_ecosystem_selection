---
title: "Estimate Response to Selection"
author: "Andrew Morris"
date: "`r Sys.Date()`"
output: html_document
---

This script takes in the flux data from script 01. It then plots the raw data
and the log-transformed data. Finally, it fits a linear model to the flux data
over time per treatment and tests a difference of slope between the positive
and the neutral treatment.

```{r initialize_packages, message=FALSE}
library(tidyverse)
library(morris)
library(broom)
library(knitr)
library(broman)
```

```{r initialize_variables}
source('functions.R')
```

```{r import_data, message=FALSE}
fluxes <- read_tsv(paste0(der_dir, 'fluxes.tsv'))

# Shift the passage numbers so the first passage becomes "Passage 0"
fluxes <-
  fluxes %>% 
  mutate(passage = passage - 1)
```

## Plot the raw data

```{r plot_raw}
ratio <- calc_plot_ratios(fluxes$passage, fluxes$ch4)

plot_flux(fluxes, passage, ch4, ratio)
#ggsave('fluxes_raw.pdf', width = 5, height = 4)
```

## Plot the log-transformed data

```{r plot_log10}
ratio_log10 <- calc_plot_ratios(fluxes$passage, fluxes$log_ch4)

plot_flux(fluxes, passage, log_ch4, ratio_log10, log10 = TRUE)

#ggsave('fluxes_log.pdf', width = 5, height = 4)
```

## Test a difference of slopes

```{r raw_model}
raw_model <- lm(ch4 ~ passage * treat, data = fluxes)

ggplot(raw_model, aes(x = .fitted, y = .resid)) + geom_point()

```

```{r response_model}
response_model <- lm(log_ch4 ~ passage * treat, data = fluxes)

ggplot(response_model, aes(x = .fitted, y = .resid)) + geom_point()

```

```{r no_treat_model}
# No treatment model
no_treat_model <- lm(log_ch4 ~ passage, data = fluxes)

# Back calculate the slope of the positive treatment
pos_slope <- 10^response_model$coef["passage:treatp"]
per_slope <- (10^response_model$coef["passage:treatp"] - 1) * 100
```

Here I fit two models. The first is the full model which includes passage number, treatment, and the interaction between the two. The second model includes only passage with no effect of treatment. Comparing the models using `anova` 

```{r compare_models}
# Compare interaction to no interaction
compare_response_mods <- anova(no_treat_model, response_model, test = 'LRT')
kable(tidy(compare_response_mods))
```

Here is the full interaction model:

```{r print_model}
kable(tidy(response_model))
```

```{r save_model}
save(response_model, compare_response_mods, per_slope, file = '../Output/response_model.Rdata')
```

The intercept for the Neutral treatment was significantly different from zero
at `r myround(tidy(response_model)[[1, 2]], 2)` (SE = `r
myround(tidy(response_model)[[1, 3]], 2)`, t = `r myround(tidy(response_model)[[1,
4]], 2)`, p = `r myround(tidy(response_model)[[1, 5]], 2)`). The Positive
treatment started at a significantly lower methane oxidation rate than the
Neutral treatment with a y-intercept of `r myround(tidy(response_model)[[3, 2]],
2)` relative to Neutral (SE = `r myround(tidy(response_model)[[3, 3]], 2)`, t = `r
myround(tidy(response_model)[[3, 4]], 2)`, p = `r myround(tidy(response_model)[[3,
5]], 2)`). There was no change in methane oxidation rate of the Neutral
treatment over the five passages (slope = `r myround(tidy(response_model)[[2, 2]],
2)`, SE = `r myround(tidy(response_model)[[2, 3]], 2)`, t = `r
myround(tidy(response_model)[[2, 4]], 2)`, p = `r myround(tidy(response_model)[[2,
5]], 2)`). By contrast, there was a significant increase in the Positive
treatment of `r myround(tidy(response_model)[[4, 2]], 2)` per passage which is
approximately a `r round((pos_slope - 1) * 100, 0)`% increase in methane
oxidation rate per passage (SE = `r myround(tidy(response_model)[[4, 3]], 2)`, t =
`r myround(tidy(response_model)[[4, 4]], 2)`, p = `r myround(tidy(response_model)[[4,
5]], 2)`).

## Previous Method

Previously, I was using the `metafor` package to test the slope of the difference between the positive and neutral line. For this model, I calculate the difference between the Positive and Neutral treatment and fit that difference as the response. I also calculate the standard error of the difference and included that variance in the model. I then fit the model `difference ~ passage` to test the slope of the difference over time.



```{r eval=FALSE}

# Standard error of the difference
sed <- function(p, n, na.rm = FALSE) {
  sqrt(se(p, na.rm = na.rm) ^ 2 + se(n, na.rm = na.rm)^ 2)
}
# Calculate deviance as p - n
deviance <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  group_by(passage, treat) %>% 
  summarize(mean = mean(estimate), .groups = "drop") %>% 
  pivot_wider(names_from = treat, values_from = mean) %>% 
  mutate(deviance = p - n)

# Calculate variance of deviance as SED
deviance$se <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  mutate(x = 1:nrow(fluxes)) %>% 
  pivot_wider(names_from = treat, values_from = estimate) %>% 
  group_by(passage) %>% 
  summarize(sed = sed(p, n, na.rm = TRUE), .groups = "drop") %>%
  pull(sed)

# Fit deviance model
fit <- rma(deviance ~ passage, se^2, method="FE", data = deviance)

plot(fit)

# Plot deviance
ggplot(deviance, aes(x = passage, y = deviance, ymin = deviance - se, ymax = deviance + se)) + 
  geom_pointrange(color = 'darkorange2') + 
  geom_abline(intercept = fit$beta[1], slope = fit$beta[2])

# Take deviance model parameters and export into a data.frame
rma_output <- data.frame(
Estimate = fit$beta,
se = fit$se,
z.value = fit$zval,
p.value = fit$pval,
upper.ci = fit$ci.lb,
lower.ci = fit$ci.ub
)

# Fit deviance model without passage 2
fit_no2 <- 
filter(deviance, passage != 2) %>% 
rma(deviance ~ passage, se^2, method="FE", data = .)

# Take deviance model withou passage 2 parameters and export into a data.frame

rma_output_no2 <- data.frame(
Estimate = fit_no2$beta,
se = fit_no2$se,
z.value = fit_no2$zval,
p.value = fit_no2$pval,
upper.ci = fit_no2$ci.lb,
lower.ci = fit_no2$ci.ub
)

# R (response to selection) for the model w/o sample 2
R_no2 <- rma_output_no2[[2, 1]]
R <- rma_output[[2, 1]]

# Plot the no2 model
filter(deviance, passage != 2) %>% 
ggplot(., aes(x = passage, y = deviance, ymin = deviance - se, ymax = deviance + se)) + 
  geom_pointrange(color = 'darkorange2') + 
  geom_abline(intercept = fit_no2$beta[1], slope = fit_no2$beta[2])

#write_tsv(deviance, '../Output/deviance.tsv')
#saveRDS(rma_output, '../Output/response.rds')
#saveRDS(fit, '../Output/dev_fit.rds')



# Calculate deviance as percentage of p - n
deviance <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  group_by(passage, treat) %>% 
  summarize(mean = mean(estimate), .groups = "drop") %>% 
  pivot_wider(names_from = treat, values_from = mean) %>% 
  mutate(deviance = (p - n) / n)

# Calculate variance of deviance as SED
deviance$se <-
  fluxes %>% 
  select(treat, passage, estimate) %>% 
  mutate(x = 1:nrow(fluxes)) %>% 
  pivot_wider(names_from = treat, values_from = estimate) %>% 
  group_by(passage) %>% 
  summarize(sed = sed(p, n, na.rm = TRUE), .groups = "drop") %>%
  pull(sed)

# Fit deviance model
fit <- rma(deviance ~ passage, se^2, method="FE", data = deviance)

plot(fit)

# Plot deviance
ggplot(deviance, aes(x = passage, y = deviance, ymin = deviance - se, ymax = deviance + se)) + 
  geom_pointrange(color = 'darkorange2') + 
  geom_abline(intercept = fit$beta[1], slope = fit$beta[2])

# Take deviance model parameters and export into a data.frame
rma_output <- data.frame(
Estimate = fit$beta,
se = fit$se,
z.value = fit$zval,
p.value = fit$pval,
upper.ci = fit$ci.lb,
lower.ci = fit$ci.ub
)

# Fit separte slopes for Positive and Neutral with robust M-estimator regression

library(MASS)
anova(
fit <- rlm(estimate ~ passage * treat, data = fluxes),
fit <- rlm(estimate ~ passage + treat, data = fluxes))

summary(fit)
anova(fit)
new_data <- cbind(fluxes, predict(fit, interval = 'confidence'))
colnames(new_data) 
ggplot(new_data, aes(x = passage, y = estimate, color = treat)) +
  theme_bw() +
  geom_jitter() +
  geom_line(aes(passage, fit)) +
  geom_ribbon(aes(ymin=lwr,ymax=upr), alpha=0.3)

ggplot(new_data, aes(x = passage, y = estimate)) +
  theme_bw() +
  geom_jitter(aes(color = treat)) +
  geom_line(aes(passage, fit, color = treat)) +
  geom_ribbon(aes(ymin=lwr,ymax=upr, group = treat), alpha=0.3) +
  ylim(-0.01, 0.08)
ggplot(fluxes, aes(x = passage, y = estimate, color = treat)) + 
  geom_point() + 
  stat_smooth(method='lm')
#ggsave('raw_fluxes.pdf')
```


